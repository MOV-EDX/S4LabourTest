# S4LabourTest

Setup Instructions:

The console application has been written against Visual Studio 2022 using .NET 8. You will need to ensure that you have this version of .NET 8 installed along with Visual Studio 2022. To run the application, simply open the `.sln` file using Visual Studio and then run the application using the green play button. A console window will open and will list the final labour cost for each employee provided in `Program.cs`.

Improvements:

The `CreateEmployee` factory method could be moved to its own factory class named `EmployeeFactory` and have one generic method whose type argument is constrained to the `IEmployee` interface. This would allow you to create the different types of employee: annual (salaried), weekly and hourly. Each of these would belong to its own class type which all inherit from a common abstract class named `Employee`, which would contain virtual implementations of the same methods defined in the current iteration of the `Employee` class, however, the hourly employee type would override the `CalculateWeeklyPay` method to use the calculation which is specific for hourly employees. The base implementation of the `CalculateWeeklyPay` method would use the calcuation for salaried and weekly employees since that is currently shared between two employee types. I would create a new method which is just for calculating the SSP and then define that on the `Employee` class. The `CalculateSickPay` method would be overriden by the hourly employee type and just call the new SSP method. On the other hand, the base implementation of `CalculateSickPay` would largely have the same logic as it currently does but would call the SSP method instead of having it defined in the method itself.

The `RateOfPay` property for `Employee` should be standardised to be the hourly rate for a couple of reasons: firstly, the `CalculateSalary` method takes the number of hours and minutes which have been worked for a given week and is a rate which is compatible with all the employee types defined thus far. Secondly, it is likely that there would be an `Employee` entity and assuming that this is going to be stored in a relational database, then having the rate of pay be dependent on the pay frequency, it creates a transitive dependency and "breaks" 3NF. Although, realistically, any pay information would likely be tied to a role which is in turn associated to an employee, and pay bands would be applied to that role, unless it was possible for two employees within the same role and same band to be earning different amounts.

There is currently no method for removing deductions from an employee and therefore I would add a new method to the `Employee` class which allowed you to remove a deduction. Moreover, the `GetFullName` method could be converted to a readonly property which is the concatenation of both the forename and surname.

Another notable improvement would be to add a `try..catch` statement around `Program.cs` which would catch any exceptions which have bubbled up and then log those to a logging platform like `Application Insights` or `Sentry` using the `ILogger` interface which is compatible with multiple logging sinks. On the other hand, exception handling could be added to either the `CreateEmployee` and `CalcuateSalary` method if it acceptable for program execution to continue if either one of these fails on an individual employee. The latter option would be more wise for a console application since it is unlikely you would want the entire execution of the program to halt because one employee threw an error, although, in the context of an API, then the former would be a better option since it is easier to return an appropriate status code in the case of an error.

There are a number of constants (e.g. national insurance) used in the application which change on a yearly basis, to improve the ease of maintenance, these constants should be stored in their own database tables and have a date tied to them. Alternatively, these could be stored as configuration settings for the application, however, having the constants persisted to a database offers a couple of advantages: a database table can be shared amongst different applications; it easier to add new entries which fit a particular schema and apply logic to ensure data consistency and it is a much more convient way of keeping track of older entries if they are needed for things like historical reports. A distinct advantage of not storing these constants as a class file but rather using some form of persisted storage, is that the program does not need to be compiled and released with each change, and it makes it possible to allow users of the application to update the constants if they need to. For example, there may be adminstrative role of the application, which allows certain settings like the national insurance information to be updated each year.

